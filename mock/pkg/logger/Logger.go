// Code generated by mockery v2.53.4. DO NOT EDIT.

package mock

import (
	context "context"
	logger "log-receiver/pkg/logger"

	mock "github.com/stretchr/testify/mock"
)

// Logger is an autogenerated mock type for the Logger type
type Logger struct {
	mock.Mock
}

// DebugF provides a mock function with given fields: msg, args
func (_m *Logger) DebugF(msg string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, msg)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// DebugK provides a mock function with given fields: msg, value
func (_m *Logger) DebugK(msg string, value interface{}) {
	_m.Called(msg, value)
}

// DebugM provides a mock function with given fields: msg, valueMap
func (_m *Logger) DebugM(msg string, valueMap map[interface{}]interface{}) {
	_m.Called(msg, valueMap)
}

// DebugW provides a mock function with given fields: msg, args
func (_m *Logger) DebugW(msg string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, msg)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// ErrorF provides a mock function with given fields: msg, args
func (_m *Logger) ErrorF(msg string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, msg)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// ErrorK provides a mock function with given fields: msg, value
func (_m *Logger) ErrorK(msg string, value interface{}) {
	_m.Called(msg, value)
}

// ErrorM provides a mock function with given fields: msg, valueMap
func (_m *Logger) ErrorM(msg string, valueMap map[interface{}]interface{}) {
	_m.Called(msg, valueMap)
}

// ErrorW provides a mock function with given fields: msg, args
func (_m *Logger) ErrorW(msg string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, msg)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// FatalF provides a mock function with given fields: msg, args
func (_m *Logger) FatalF(msg string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, msg)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// FatalK provides a mock function with given fields: msg, value
func (_m *Logger) FatalK(msg string, value interface{}) {
	_m.Called(msg, value)
}

// FatalM provides a mock function with given fields: msg, valueMap
func (_m *Logger) FatalM(msg string, valueMap map[interface{}]interface{}) {
	_m.Called(msg, valueMap)
}

// FatalW provides a mock function with given fields: msg, args
func (_m *Logger) FatalW(msg string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, msg)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// InfoF provides a mock function with given fields: msg, args
func (_m *Logger) InfoF(msg string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, msg)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// InfoK provides a mock function with given fields: msg, value
func (_m *Logger) InfoK(msg string, value interface{}) {
	_m.Called(msg, value)
}

// InfoM provides a mock function with given fields: msg, valueMap
func (_m *Logger) InfoM(msg string, valueMap map[interface{}]interface{}) {
	_m.Called(msg, valueMap)
}

// InfoW provides a mock function with given fields: msg, args
func (_m *Logger) InfoW(msg string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, msg)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// Output provides a mock function with given fields: callDepth, s
func (_m *Logger) Output(callDepth int, s string) error {
	ret := _m.Called(callDepth, s)

	if len(ret) == 0 {
		panic("no return value specified for Output")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, string) error); ok {
		r0 = rf(callDepth, s)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Panic provides a mock function with given fields: format, args
func (_m *Logger) Panic(format string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, format)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// WarnF provides a mock function with given fields: msg, args
func (_m *Logger) WarnF(msg string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, msg)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// WarnK provides a mock function with given fields: msg, value
func (_m *Logger) WarnK(msg string, value interface{}) {
	_m.Called(msg, value)
}

// WarnM provides a mock function with given fields: msg, valueMap
func (_m *Logger) WarnM(msg string, valueMap map[interface{}]interface{}) {
	_m.Called(msg, valueMap)
}

// WarnW provides a mock function with given fields: msg, args
func (_m *Logger) WarnW(msg string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, msg)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// With provides a mock function with given fields: _a0
func (_m *Logger) With(_a0 ...logger.InfLogKeyValue) logger.Logger {
	_va := make([]interface{}, len(_a0))
	for _i := range _a0 {
		_va[_i] = _a0[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for With")
	}

	var r0 logger.Logger
	if rf, ok := ret.Get(0).(func(...logger.InfLogKeyValue) logger.Logger); ok {
		r0 = rf(_a0...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(logger.Logger)
		}
	}

	return r0
}

// WithAnyMap provides a mock function with given fields: valueMap
func (_m *Logger) WithAnyMap(valueMap map[interface{}]interface{}) logger.Logger {
	ret := _m.Called(valueMap)

	if len(ret) == 0 {
		panic("no return value specified for WithAnyMap")
	}

	var r0 logger.Logger
	if rf, ok := ret.Get(0).(func(map[interface{}]interface{}) logger.Logger); ok {
		r0 = rf(valueMap)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(logger.Logger)
		}
	}

	return r0
}

// WithClosures provides a mock function with given fields: closures
func (_m *Logger) WithClosures(closures ...logger.ClosureFunc) logger.Logger {
	_va := make([]interface{}, len(closures))
	for _i := range closures {
		_va[_i] = closures[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WithClosures")
	}

	var r0 logger.Logger
	if rf, ok := ret.Get(0).(func(...logger.ClosureFunc) logger.Logger); ok {
		r0 = rf(closures...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(logger.Logger)
		}
	}

	return r0
}

// WithContext provides a mock function with given fields: ctx
func (_m *Logger) WithContext(ctx context.Context) logger.Logger {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for WithContext")
	}

	var r0 logger.Logger
	if rf, ok := ret.Get(0).(func(context.Context) logger.Logger); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(logger.Logger)
		}
	}

	return r0
}

// WithLogger provides a mock function with given fields: ctx, log
func (_m *Logger) WithLogger(ctx context.Context, log logger.Logger) context.Context {
	ret := _m.Called(ctx, log)

	if len(ret) == 0 {
		panic("no return value specified for WithLogger")
	}

	var r0 context.Context
	if rf, ok := ret.Get(0).(func(context.Context, logger.Logger) context.Context); ok {
		r0 = rf(ctx, log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(context.Context)
		}
	}

	return r0
}

// NewLogger creates a new instance of Logger. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLogger(t interface {
	mock.TestingT
	Cleanup(func())
}) *Logger {
	mock := &Logger{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
